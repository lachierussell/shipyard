package nginx

import (
	"bytes"
	_ "embed"
	"fmt"
	"sort"
	"strings"
	"text/template"
	"time"

	"github.com/lachierussell/shipyard/config"
)

//go:embed backend_proxy.conf.tmpl
var backendProxyTmplStr string

//go:embed backend_proxy_https.conf.tmpl
var backendProxyHTTPSTmplStr string

//go:embed site_combined.conf.tmpl
var siteCombinedTmplStr string

//go:embed site_combined_https.conf.tmpl
var siteCombinedHTTPSTmplStr string

//go:embed nginx_override_example.conf.tmpl
var overrideExampleStr string

var backendProxyTmpl = template.Must(template.New("backend_proxy").Delims("<%", "%>").Parse(backendProxyTmplStr))
var backendProxyHTTPSTmpl = template.Must(template.New("backend_proxy_https").Delims("<%", "%>").Parse(backendProxyHTTPSTmplStr))
var siteCombinedTmpl = template.Must(template.New("site_combined").Delims("<%", "%>").Parse(siteCombinedTmplStr))
var siteCombinedHTTPSTmpl = template.Must(template.New("site_combined_https").Delims("<%", "%>").Parse(siteCombinedHTTPSTmplStr))

type backendProxyData struct {
	Domain      string
	AcmeWebroot string
	Location    string
	ListenPort  int
	SSLCert     string
	SSLKey      string
}

type siteCombinedData struct {
	Domain       string
	AcmeWebroot  string
	FrontendRoot string
	ProxyPath    string
	ListenPort   int
	SSLCert      string
	SSLKey       string
}

// NormalizeDomainName converts "example.com" to "example_com" for variable naming
// Also replaces hyphens since nginx variables can't contain them
func NormalizeDomainName(domain string) string {
	result := strings.ReplaceAll(domain, ".", "_")
	result = strings.ReplaceAll(result, "-", "_")
	return result
}

// GenerateOverrideConf creates the override.conf file content with map/geo blocks
func GenerateOverrideConf(cfg *config.Config) string {
	var sb strings.Builder

	sb.WriteString("# MANAGED BY SHIPYARD — DO NOT EDIT\n")
	sb.WriteString(fmt.Sprintf("# Generated: %s\n\n", time.Now().UTC().Format(time.RFC3339)))

	// Version selection map
	// Note: nginx doesn't support {n} quantifier in regexes; using ~.+ instead.
	// The Go API handler validates that it's 7-40 hex chars (git short or long hash).
	sb.WriteString(`# --- Version selection: valid git hash (7-40 char hex) or "latest" ---
map $arg_override $frontend_version {
    default      latest;
    ~.+          $arg_override;
}

`)

	// Is override active?
	sb.WriteString(`# --- Is an override active? (used to gate header + access) ---
map $arg_override $is_override {
    default  0;
    ~.+      1;
}

`)

	// X-Robots-Tag value
	sb.WriteString(`# --- X-Robots-Tag value (empty string = header not meaningful) ---
map $is_override $xrobots_value {
    default  "";
    1        "noindex, nofollow";
}

`)

	// Per-site geo blocks (IP whitelist) - sort for deterministic output
	sb.WriteString("# --- Per-site IP whitelist ---\n")
	siteNames := make([]string, 0, len(cfg.Site))
	for name := range cfg.Site {
		siteNames = append(siteNames, name)
	}
	sort.Strings(siteNames)

	for _, domain := range siteNames {
		site := cfg.Site[domain]
		normalized := NormalizeDomainName(domain)
		sb.WriteString(fmt.Sprintf("# site: %s\n", domain))
		sb.WriteString(fmt.Sprintf("geo $override_allowed_%s {\n", normalized))
		sb.WriteString("    default         0;\n")
		for _, ip := range site.OverrideIPs {
			sb.WriteString(fmt.Sprintf("    %s 1;\n", ip))
		}
		sb.WriteString("}\n\n")
	}

	// Per-site access decision maps (combined)
	sb.WriteString("# --- Per-site access decision (combined map) ---\n")
	for _, domain := range siteNames {
		normalized := NormalizeDomainName(domain)
		sb.WriteString(fmt.Sprintf("map \"$is_override:$override_allowed_%s\" $override_access_%s {\n", normalized, normalized))
		sb.WriteString("    \"0:0\" 1;\n")
		sb.WriteString("    \"0:1\" 1;\n")
		sb.WriteString("    \"1:0\" 0;\n")
		sb.WriteString("    \"1:1\" 1;\n")
		sb.WriteString("}\n\n")
	}

	return sb.String()
}

// GenerateMainConf creates the main nginx.conf (written once during bootstrap)
func GenerateMainConf() string {
	return `# MANAGED BY SHIPYARD — DO NOT EDIT
worker_processes auto;
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    access_log  /var/log/nginx/access.log combined;

    sendfile        on;
    tcp_nopush      on;
    keepalive_timeout  65;

    # Allow large uploads for deployments (500MB)
    client_max_body_size 500M;

    # Override subsystem (map/geo blocks) — regenerated by shipyard
    include /usr/local/etc/nginx/override.conf;

    # Per-site server blocks — user-provided
    include /usr/local/etc/nginx/sites-enabled/*.conf;
}
`
}

// GenerateRobotsTxt creates a permissive default robots.txt
func GenerateRobotsTxt() string {
	return `User-agent: *
Allow: /
`
}

// AcmeWebroot is the directory where ACME challenges are served from
const AcmeWebroot = "/var/www/acme"

// GenerateHTTPOnlyConfig creates a minimal HTTP server block for ACME challenge
// This is used during initial certificate acquisition before SSL is available
func GenerateHTTPOnlyConfig(domain string) string {
	var sb strings.Builder
	sb.WriteString("# Temporary HTTP config for ACME challenge (auto-generated by Shipyard)\n")
	sb.WriteString("server {\n")
	sb.WriteString("    listen 80;\n")
	sb.WriteString("    listen [::]:80;\n")
	sb.WriteString(fmt.Sprintf("    server_name %s;\n", domain))
	sb.WriteString("\n")
	sb.WriteString("    # ACME challenge for Let's Encrypt\n")
	sb.WriteString(fmt.Sprintf("    location /.well-known/acme-challenge/ {\n"))
	sb.WriteString(fmt.Sprintf("        root %s;\n", AcmeWebroot))
	sb.WriteString("    }\n")
	sb.WriteString("\n")
	sb.WriteString("    location / {\n")
	sb.WriteString("        return 503 'Site is being configured';\n")
	sb.WriteString("    }\n")
	sb.WriteString("}\n")
	return sb.String()
}

// TransformToHTTPS takes a user-provided nginx server config and:
// 1. Transforms it to use HTTPS (listen 443 ssl, adds SSL directives)
// 2. Generates an HTTP->HTTPS redirect block with ACME passthrough
// Returns the combined configuration (redirect block + HTTPS block)
func TransformToHTTPS(nginxConfig string, domain string, sslCert string, sslKey string) string {
	var sb strings.Builder

	// Generate HTTP redirect block with ACME passthrough
	sb.WriteString("# HTTP -> HTTPS redirect (auto-generated by Shipyard)\n")
	sb.WriteString("server {\n")
	sb.WriteString("    listen 80;\n")
	sb.WriteString("    listen [::]:80;\n")
	sb.WriteString(fmt.Sprintf("    server_name %s;\n", domain))
	sb.WriteString("\n")
	sb.WriteString("    # ACME challenge for Let's Encrypt certificate renewal\n")
	sb.WriteString(fmt.Sprintf("    location /.well-known/acme-challenge/ {\n"))
	sb.WriteString(fmt.Sprintf("        root %s;\n", AcmeWebroot))
	sb.WriteString("    }\n")
	sb.WriteString("\n")
	sb.WriteString("    location / {\n")
	sb.WriteString("        return 301 https://$host$request_uri;\n")
	sb.WriteString("    }\n")
	sb.WriteString("}\n\n")

	// Transform the user's config to HTTPS
	httpsConfig := transformServerBlockToHTTPS(nginxConfig, sslCert, sslKey)
	sb.WriteString("# HTTPS server block\n")
	sb.WriteString(httpsConfig)

	return sb.String()
}

// transformServerBlockToHTTPS modifies a server block to use SSL
func transformServerBlockToHTTPS(config string, sslCert string, sslKey string) string {
	lines := strings.Split(config, "\n")
	var result []string
	inServerBlock := false
	sslDirectivesAdded := false

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		// Detect server block start
		if strings.HasPrefix(trimmed, "server") && strings.Contains(trimmed, "{") {
			inServerBlock = true
			result = append(result, line)
			continue
		}

		// Transform listen directives
		if inServerBlock && strings.HasPrefix(trimmed, "listen") && !strings.Contains(trimmed, "ssl") {
			// Replace listen 80 with listen 443 ssl
			if strings.Contains(trimmed, "80") {
				newLine := strings.Replace(line, "80", "443 ssl", 1)
				result = append(result, newLine)

				// Add SSL directives after the first listen directive
				if !sslDirectivesAdded {
					indent := getIndent(line)
					result = append(result, indent+"listen [::]:443 ssl;")
					result = append(result, "")
					result = append(result, indent+"# SSL configuration (auto-generated by Shipyard)")
					result = append(result, fmt.Sprintf("%sssl_certificate %s;", indent, sslCert))
					result = append(result, fmt.Sprintf("%sssl_certificate_key %s;", indent, sslKey))
					result = append(result, indent+"ssl_session_timeout 1d;")
					result = append(result, indent+"ssl_session_cache shared:SSL:50m;")
					result = append(result, indent+"ssl_session_tickets off;")
					result = append(result, "")
					result = append(result, indent+"# Modern SSL configuration")
					result = append(result, indent+"ssl_protocols TLSv1.2 TLSv1.3;")
					result = append(result, indent+"ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;")
					result = append(result, indent+"ssl_prefer_server_ciphers off;")
					result = append(result, "")
					sslDirectivesAdded = true
				}
				continue
			}
		}

		result = append(result, line)
	}

	return strings.Join(result, "\n")
}

// getIndent returns the leading whitespace of a line
func getIndent(line string) string {
	for i, c := range line {
		if c != ' ' && c != '\t' {
			return line[:i]
		}
	}
	return line
}

// GenerateBackendProxyConfig creates a default nginx config for proxying to a backend service
func GenerateBackendProxyConfig(domain string, listenPort int, proxyPath string) string {
	location := "/"
	if proxyPath != "" && proxyPath != "/" {
		location = proxyPath
	}

	var buf bytes.Buffer
	if err := backendProxyTmpl.Execute(&buf, backendProxyData{
		Domain:      domain,
		AcmeWebroot: AcmeWebroot,
		Location:    location,
		ListenPort:  listenPort,
	}); err != nil {
		return fmt.Sprintf("# Template error: %v\n", err)
	}

	return buf.String()
}

// GenerateBackendProxyConfigHTTPS creates an HTTPS nginx config for proxying to a backend service
func GenerateBackendProxyConfigHTTPS(domain string, listenPort int, proxyPath string, sslCert string, sslKey string) string {
	location := "/"
	if proxyPath != "" && proxyPath != "/" {
		location = proxyPath
	}

	var buf bytes.Buffer
	if err := backendProxyHTTPSTmpl.Execute(&buf, backendProxyData{
		Domain:      domain,
		AcmeWebroot: AcmeWebroot,
		Location:    location,
		ListenPort:  listenPort,
		SSLCert:     sslCert,
		SSLKey:      sslKey,
	}); err != nil {
		return fmt.Sprintf("# Template error: %v\n", err)
	}

	return buf.String()
}

// GenerateSiteCombinedConfig creates an nginx config with frontend + backend proxy
func GenerateSiteCombinedConfig(domain string, frontendRoot string, listenPort int, proxyPath string) string {
	if proxyPath == "" {
		proxyPath = "/api"
	}

	var buf bytes.Buffer
	if err := siteCombinedTmpl.Execute(&buf, siteCombinedData{
		Domain:       domain,
		AcmeWebroot:  AcmeWebroot,
		FrontendRoot: frontendRoot,
		ProxyPath:    proxyPath,
		ListenPort:   listenPort,
	}); err != nil {
		return fmt.Sprintf("# Template error: %v\n", err)
	}

	return buf.String()
}

// GenerateSiteCombinedConfigHTTPS creates an HTTPS nginx config with frontend + backend proxy
func GenerateSiteCombinedConfigHTTPS(domain string, frontendRoot string, listenPort int, proxyPath string, sslCert string, sslKey string) string {
	if proxyPath == "" {
		proxyPath = "/api"
	}

	var buf bytes.Buffer
	if err := siteCombinedHTTPSTmpl.Execute(&buf, siteCombinedData{
		Domain:       domain,
		AcmeWebroot:  AcmeWebroot,
		FrontendRoot: frontendRoot,
		ProxyPath:    proxyPath,
		ListenPort:   listenPort,
		SSLCert:      sslCert,
		SSLKey:       sslKey,
	}); err != nil {
		return fmt.Sprintf("# Template error: %v\n", err)
	}

	return buf.String()
}

// UserConfigData contains the template variables available to user-provided nginx configs.
type UserConfigData struct {
	Domain       string
	FrontendRoot string
	ProxyPath    string
	ListenPort   int
	AcmeWebroot  string
	SSLEnabled   bool
}

// RenderUserConfig processes a user-provided nginx config as a Go template
// with <% %> delimiters, injecting site-specific data.
// Returns the rendered config or an error if the template is invalid.
func RenderUserConfig(nginxConfig string, siteName string, cfg *config.Config) (string, error) {
	site, ok := cfg.Site[siteName]
	if !ok {
		return "", fmt.Errorf("site not found: %s", siteName)
	}

	data := UserConfigData{
		Domain:       siteName,
		FrontendRoot: site.FrontendRoot,
		AcmeWebroot:  AcmeWebroot,
		SSLEnabled:   site.SSLEnabled,
	}

	if site.Backend != nil {
		data.ProxyPath = site.Backend.ProxyPath
		data.ListenPort = site.Backend.ListenPort
	}

	tmpl, err := template.New("user_config").Delims("<%", "%>").Parse(nginxConfig)
	if err != nil {
		return "", fmt.Errorf("parse nginx config template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("render nginx config template: %w", err)
	}

	return buf.String(), nil
}

// GetOverrideExample returns the example nginx override template with
// documentation of available template variables.
func GetOverrideExample() string {
	return overrideExampleStr
}
